/**
 * Modules in this bundle
 * @license
 * 
 * empower:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   contributors: James Talmage
 *   homepage: http://github.com/power-assert-js/empower
 *   version: 1.1.0
 * 
 * array-filter:
 *   license: MIT
 *   author: Julian Gruber <mail@juliangruber.com>
 *   maintainers: juliangruber <julian@juliangruber.com>
 *   homepage: https://github.com/juliangruber/array-filter
 *   version: 1.0.0
 * 
 * array-foreach:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   homepage: https://github.com/twada/array-foreach
 *   version: 1.0.1
 * 
 * array-map:
 *   license: MIT
 *   author: James Halliday <mail@substack.net>
 *   maintainers: substack <mail@substack.net>
 *   homepage: https://github.com/substack/array-map
 *   version: 0.0.0
 * 
 * array-reduce:
 *   license: MIT
 *   author: James Halliday <mail@substack.net>
 *   maintainers: substack <mail@substack.net>
 *   homepage: https://github.com/substack/array-reduce
 *   version: 0.0.0
 * 
 * array-some:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   homepage: https://github.com/twada/array-some
 *   version: 1.0.0
 * 
 * deep-equal:
 *   license: MIT
 *   author: James Halliday <mail@substack.net>
 *   maintainers: substack <mail@substack.net>
 *   homepage: https://github.com/substack/node-deep-equal#readme
 *   version: 1.0.1
 * 
 * define-properties:
 *   license: MIT
 *   author: Jordan Harband
 *   maintainers: ljharb <ljharb@gmail.com>
 *   homepage: https://github.com/ljharb/define-properties#readme
 *   version: 1.1.2
 * 
 * escallmatch:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   homepage: https://github.com/twada/escallmatch
 *   version: 1.4.2
 * 
 * esprima:
 *   license: BSD-2-Clause
 *   author: Ariya Hidayat <ariya.hidayat@gmail.com>
 *   maintainers: ariya <ariya.hidayat@gmail.com>
 *   homepage: http://esprima.org
 *   version: 2.7.0
 * 
 * espurify:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   homepage: https://github.com/estools/espurify
 *   version: 1.3.0
 * 
 * estraverse:
 *   license: BSD-2-Clause
 *   maintainers: constellation <utatane.tea@gmail.com>, michaelficarra <npm@michael.ficarra.me>, nzakas <nicholas@nczconsulting.com>
 *   homepage: https://github.com/estools/estraverse
 *   version: 4.1.1
 * 
 * foreach:
 *   license: MIT
 *   author: Manuel Stofer <manuel@takimata.ch>
 *   maintainers: manuelstofer <manuel@takimata.ch>
 *   contributors: Manuel Stofer, Jordan Harband
 *   homepage: https://github.com/manuelstofer/foreach
 *   version: 2.0.5
 * 
 * function-bind:
 *   licenses: MIT
 *   author: Raynos <raynos2@gmail.com>
 *   maintainers: raynos <raynos2@gmail.com>
 *   contributors: Raynos
 *   homepage: https://github.com/Raynos/function-bind
 *   version: 0.1.0
 * 
 * has:
 *   licenses: MIT
 *   author: Thiago de Arruda <tpadilha84@gmail.com>
 *   maintainers: tarruda <tpadilha84@gmail.com>
 *   homepage: https://github.com/tarruda/has
 *   version: 0.0.1
 * 
 * indexof:
 *   maintainers: tjholowaychuk <tj@vision-media.ca>
 *   version: 0.0.1
 * 
 * isarray:
 *   license: MIT
 *   author: Julian Gruber <mail@juliangruber.com>
 *   maintainers: juliangruber <julian@juliangruber.com>
 *   homepage: https://github.com/juliangruber/isarray
 *   version: 0.0.1
 * 
 * object-create:
 *   licenses: MIT
 *   author: Thiago de Arruda <tpadilha84@gmail.com>
 *   maintainers: tarruda <tpadilha84@gmail.com>
 *   homepage: https://github.com/tarruda/object-create
 *   version: 0.1.0
 * 
 * object-define-property:
 *   licenses: MIT
 *   author: Thiago de Arruda <tpadilha84@gmail.com>
 *   maintainers: tarruda <tpadilha84@gmail.com>
 *   homepage: https://github.com/tarruda/object-define-property
 *   version: 0.1.0
 * 
 * object-keys:
 *   license: MIT
 *   author: Jordan Harband <ljharb@gmail.com>
 *   maintainers: ljharb <ljharb@gmail.com>
 *   contributors: Jordan Harband <ljharb@gmail.com>, Raynos <raynos2@gmail.com>, Nathan Rajlich <nathan@tootallnate.net>, Ivan Starkov <istarkov@gmail.com>, Gary Katsevman <git@gkatsev.com>
 *   homepage: https://github.com/ljharb/object-keys#readme
 *   version: 1.0.9
 * 
 * xtend:
 *   license: MIT
 *   author: Raynos <raynos2@gmail.com>
 *   maintainers: raynos <raynos2@gmail.com>
 *   contributors: Jake Verbaten, Matt Esch
 *   homepage: https://github.com/Raynos/xtend
 *   version: 4.0.1
 * 
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.empower = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/**
 * empower - Power Assert feature enhancer for assert function/object.
 *
 * https://github.com/power-assert-js/empower
 *
 * Copyright (c) 2013-2015 Takuto Wada
 * Licensed under the MIT license.
 *   https://github.com/power-assert-js/empower/blob/master/MIT-LICENSE.txt
 */
var defaultOptions = _dereq_('./lib/default-options');
var Decorator = _dereq_('./lib/decorator');
var capturable = _dereq_('./lib/capturable');
var create = _dereq_('object-create');
var slice = Array.prototype.slice;
var extend = _dereq_('xtend/mutable');
var define = _dereq_('define-properties');

/**
 * Enhance Power Assert feature to assert function/object.
 * @param assert target assert function or object to enhance
 * @param formatter power assert format function
 * @param options enhancement options
 * @return enhanced assert function/object
 */
function empower (assert, formatter, options) {
    var typeOfAssert = (typeof assert);
    var enhancedAssert;
    if ((typeOfAssert !== 'object' && typeOfAssert !== 'function') || assert === null) {
        throw new TypeError('empower argument should be a function or object.');
    }
    if (isEmpowered(assert)) {
        return assert;
    }
    switch (typeOfAssert) {
    case 'function':
        enhancedAssert = empowerAssertFunction(assert, formatter, options);
        break;
    case 'object':
        enhancedAssert = empowerAssertObject(assert, formatter, options);
        break;
    default:
        throw new Error('Cannot be here');
    }
    define(enhancedAssert, capturable());
    return enhancedAssert;
}

function empowerAssertObject (assertObject, formatter, options) {
    var config = extend(defaultOptions(), options);
    var target = config.destructive ? assertObject : create(assertObject);
    var decorator = new Decorator(target, formatter, config);
    return extend(target, decorator.enhancement());
}

function empowerAssertFunction (assertFunction, formatter, options) {
    var config = extend(defaultOptions(), options);
    if (config.destructive) {
        throw new Error('cannot use destructive:true to function.');
    }
    var decorator = new Decorator(assertFunction, formatter, config);
    var enhancement = decorator.enhancement();
    var powerAssert;
    if (typeof enhancement === 'function') {
        powerAssert = function powerAssert () {
            return enhancement.apply(null, slice.apply(arguments));
        };
    } else {
        powerAssert = function powerAssert () {
            return assertFunction.apply(null, slice.apply(arguments));
        };
    }
    extend(powerAssert, assertFunction);
    return extend(powerAssert, enhancement);
}

function isEmpowered (assertObjectOrFunction) {
    return (typeof assertObjectOrFunction._capt === 'function') && (typeof assertObjectOrFunction._expr === 'function');
}

empower.defaultOptions = defaultOptions;
module.exports = empower;

},{"./lib/capturable":2,"./lib/decorator":4,"./lib/default-options":5,"define-properties":10,"object-create":27,"xtend/mutable":35}],2:[function(_dereq_,module,exports){
'use strict';

module.exports = function capturable () {
    var events = [];

    function _capt (value, espath) {
        events.push({value: value, espath: espath});
        return value;
    }

    function _expr (value, args) {
        var captured = events;
        events = [];
        var source = {
            content: args.content,
            filepath: args.filepath,
            line: args.line
        };
        if (args.generator) {
            source.generator = true;
        }
        if (args.async) {
            source.async = true;
        }
        return {
            powerAssertContext: {
                value: value,
                events: captured
            },
            source: source
        };
    }

    return {
        _capt: _capt,
        _expr: _expr
    };
};

},{}],3:[function(_dereq_,module,exports){
'use strict';

var slice = Array.prototype.slice;
var map = _dereq_('array-map');
var some = _dereq_('array-some');

function decorate (callSpec, decorator) {
    var func = callSpec.func;
    var thisObj = callSpec.thisObj;
    var numArgsToCapture = callSpec.numArgsToCapture;

    return function decoratedAssert () {
        var context, message, args = slice.apply(arguments);
        if (some(args, isCaptured)) {
            var values = map(args.slice(0, numArgsToCapture), function (arg) {
                if (isNotCaptured(arg)) {
                    return arg;
                }
                if (!context) {
                    context = {
                        source: arg.source,
                        args: []
                    };
                }
                context.args.push({
                    value: arg.powerAssertContext.value,
                    events: arg.powerAssertContext.events
                });
                return arg.powerAssertContext.value;
            });

            if (numArgsToCapture === (args.length - 1)) {
                message = args[args.length - 1];
            }

            var invocation = {
                thisObj: thisObj,
                func: func,
                values: values,
                message: message
            };
            return decorator.concreteAssert(invocation, context);
        } else {
            return func.apply(thisObj, args);
        }
    };
}

function isNotCaptured (value) {
    return !isCaptured(value);
}

function isCaptured (value) {
    return (typeof value === 'object') &&
        (value !== null) &&
        (typeof value.powerAssertContext !== 'undefined');
}

module.exports = decorate;

},{"array-map":8,"array-some":9}],4:[function(_dereq_,module,exports){
'use strict';

var escallmatch = _dereq_('escallmatch');
var extend = _dereq_('xtend/mutable');
var forEach = _dereq_('array-foreach');
var map = _dereq_('array-map');
var filter = _dereq_('array-filter');
var decorate = _dereq_('./decorate');


function Decorator (receiver, formatter, config) {
    this.receiver = receiver;
    this.formatter = formatter;
    this.config = config;
    this.matchers = map(config.patterns, escallmatch);
    this.eagerEvaluation = !(config.modifyMessageOnRethrow || config.saveContextOnRethrow);
}

Decorator.prototype.enhancement = function () {
    var that = this;
    var container = this.container();
    forEach(filter(this.matchers, methodCall), function (matcher) {
        var methodName = detectMethodName(matcher.calleeAst());
        if (typeof that.receiver[methodName] === 'function') {
            var callSpec = {
                thisObj: that.receiver,
                func: that.receiver[methodName],
                numArgsToCapture: numberOfArgumentsToCapture(matcher)
            };
            container[methodName] = decorate(callSpec, that);
        }
    });
    return container;
};

Decorator.prototype.container = function () {
    var basement = {};
    if (typeof this.receiver === 'function') {
        var candidates = filter(this.matchers, functionCall);
        if (candidates.length === 1) {
            var callSpec = {
                thisObj: null,
                func: this.receiver,
                numArgsToCapture: numberOfArgumentsToCapture(candidates[0])
            };
            basement = decorate(callSpec, this);
        }
    }
    return basement;
};

Decorator.prototype.concreteAssert = function (invocation, context) {
    var func = invocation.func;
    var thisObj = invocation.thisObj;
    var args = invocation.values;
    var message = invocation.message;
    if (this.eagerEvaluation) {
        var poweredMessage = this.buildPowerAssertText(message, context);
        return func.apply(thisObj, args.concat(poweredMessage));
    }
    try {
        return func.apply(thisObj, args.concat(message));
    } catch (e) {
        throw this.errorToRethrow(e, message, context);
    }
};

Decorator.prototype.errorToRethrow = function (e, originalMessage, context) {
    if (e.name !== 'AssertionError') {
        return e;
    }
    if (typeof this.receiver.AssertionError !== 'function') {
        return e;
    }
    var f = new this.receiver.AssertionError({
        actual: e.actual,
        expected: e.expected,
        operator: e.operator,
        message: this.config.modifyMessageOnRethrow ? this.buildPowerAssertText(originalMessage, context) : e.message,
        stackStartFunction: Decorator.prototype.concreteAssert
    });
    if (this.config.saveContextOnRethrow) {
        f.powerAssertContext = context;
    }
    return f;
};

Decorator.prototype.buildPowerAssertText = function (message, context) {
    var powerAssertText = this.formatter(context);
    return message ? message + ' ' + powerAssertText : powerAssertText;
};


function numberOfArgumentsToCapture (matcher) {
    var argSpecs = matcher.argumentSignatures();
    var len = argSpecs.length;
    var lastArg;
    if (0 < len) {
        lastArg = argSpecs[len - 1];
        if (lastArg.name === 'message' && lastArg.kind === 'optional') {
            len -= 1;
        }
    }
    return len;
}


function detectMethodName (node) {
    if (node.type === 'MemberExpression') {
        return node.property.name;
    }
    return null;
}


function functionCall (matcher) {
    return matcher.calleeAst().type === 'Identifier';
}


function methodCall (matcher) {
    return matcher.calleeAst().type === 'MemberExpression';
}


module.exports = Decorator;

},{"./decorate":3,"array-filter":6,"array-foreach":7,"array-map":8,"escallmatch":12,"xtend/mutable":35}],5:[function(_dereq_,module,exports){
'use strict';

module.exports = function defaultOptions () {
    return {
        destructive: false,
        modifyMessageOnRethrow: false,
        saveContextOnRethrow: false,
        patterns: [
            'assert(value, [message])',
            'assert.ok(value, [message])',
            'assert.equal(actual, expected, [message])',
            'assert.notEqual(actual, expected, [message])',
            'assert.strictEqual(actual, expected, [message])',
            'assert.notStrictEqual(actual, expected, [message])',
            'assert.deepEqual(actual, expected, [message])',
            'assert.notDeepEqual(actual, expected, [message])',
            'assert.deepStrictEqual(actual, expected, [message])',
            'assert.notDeepStrictEqual(actual, expected, [message])'
        ]
    };
};

},{}],6:[function(_dereq_,module,exports){

/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */

module.exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError;
  if ('function' != typeof fn) throw new TypeError;
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }
  return ret;
};

var hasOwn = Object.prototype.hasOwnProperty;

},{}],7:[function(_dereq_,module,exports){
/**
 * array-foreach
 *   Array#forEach ponyfill for older browsers
 *   (Ponyfill: A polyfill that doesn't overwrite the native method)
 * 
 * https://github.com/twada/array-foreach
 *
 * Copyright (c) 2015 Takuto Wada
 * Licensed under the MIT license.
 *   http://twada.mit-license.org/
 */
'use strict';

module.exports = function forEach (ary, callback, thisArg) {
    if (ary.forEach) {
        ary.forEach(callback, thisArg);
        return;
    }
    for (var i = 0; i < ary.length; i+=1) {
        callback.call(thisArg, ary[i], i, ary);
    }
};

},{}],8:[function(_dereq_,module,exports){
module.exports = function (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = xs[i];
        if (hasOwn.call(xs, i)) res.push(f(x, i, xs));
    }
    return res;
};

var hasOwn = Object.prototype.hasOwnProperty;

},{}],9:[function(_dereq_,module,exports){
/**
 * array-some
 *   Array#some ponyfill for older browsers
 *   (Ponyfill: A polyfill that doesn't overwrite the native method)
 * 
 * https://github.com/twada/array-some
 *
 * Copyright (c) 2015 Takuto Wada
 * Licensed under the MIT license.
 *   http://twada.mit-license.org/
 */
'use strict';

module.exports = function some (ary, callback, thisArg) {
    if (ary.some) {
        return ary.some(callback, thisArg);
    }
    for (var i = 0; i < ary.length; i+=1) {
        if (callback.call(thisArg, ary[i], i, ary)) {
            return true;
        }
    }
    return false;
};

},{}],10:[function(_dereq_,module,exports){
'use strict';

var keys = _dereq_('object-keys');
var foreach = _dereq_('foreach');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) { return false; }
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"foreach":11,"object-keys":32}],11:[function(_dereq_,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],12:[function(_dereq_,module,exports){
/**
 * escallmatch:
 *   ECMAScript CallExpression matcher made from function/method signature
 * 
 * https://github.com/twada/escallmatch
 *
 * Copyright (c) 2014-2015 Takuto Wada
 * Licensed under the MIT license.
 *   http://twada.mit-license.org/
 */
'use strict';
/* jshint -W024 */

var esprima = _dereq_('esprima');
var estraverse = _dereq_('estraverse');
var espurify = _dereq_('espurify');
var syntax = estraverse.Syntax;
var hasOwn = Object.prototype.hasOwnProperty;
var forEach = _dereq_('array-foreach');
var map = _dereq_('array-map');
var filter = _dereq_('array-filter');
var reduce = _dereq_('array-reduce');
var indexOf = _dereq_('indexof');
var deepEqual = _dereq_('deep-equal');
var notCallExprMessage = 'Argument should be in the form of CallExpression';
var duplicatedArgMessage = 'Duplicate argument name: ';
var invalidFormMessage = 'Argument should be in the form of `name` or `[name]`';

function createMatcher (signatureStr, options) {
    var ast = extractExpressionFrom(esprima.parse(signatureStr));
    return new Matcher(ast, options || {});
}

function Matcher (signatureAst, options) {
    this.visitorKeys = options.visitorKeys || estraverse.VisitorKeys;
    this.signatureAst = signatureAst;
    this.signatureCalleeDepth = astDepth(signatureAst.callee, this.visitorKeys);
    this.numMaxArgs = this.signatureAst.arguments.length;
    this.numMinArgs = filter(this.signatureAst.arguments, identifiers).length;
}

Matcher.prototype.test = function (currentNode) {
    var calleeMatched = this.isCalleeMatched(currentNode);
    var numArgs;
    if (calleeMatched) {
        numArgs = currentNode.arguments.length;
        return this.numMinArgs <= numArgs && numArgs <= this.numMaxArgs;
    }
    return false;
};

Matcher.prototype.matchArgument = function (currentNode, parentNode) {
    if (isCalleeOfParent(currentNode, parentNode)) {
        return null;
    }
    if (this.test(parentNode)) {
        var indexOfCurrentArg = indexOf(parentNode.arguments, currentNode);
        var numOptional = parentNode.arguments.length - this.numMinArgs;
        var matchedSignatures = reduce(this.argumentSignatures(), function (accum, argSig) {
            if (argSig.kind === 'mandatory') {
                accum.push(argSig);
            }
            if (argSig.kind === 'optional' && 0 < numOptional) {
                numOptional -= 1;
                accum.push(argSig);
            }
            return accum;
        }, []);
        return matchedSignatures[indexOfCurrentArg];
    }
    return null;
};

Matcher.prototype.calleeAst = function () {
    return espurify(this.signatureAst.callee);
};

Matcher.prototype.argumentSignatures = function () {
    return map(this.signatureAst.arguments, toArgumentSignature);
};

Matcher.prototype.isCalleeMatched = function (node) {
    if (!isCallExpression(node)) {
        return false;
    }
    if (!this.isSameDepthAsSignatureCallee(node.callee)) {
        return false;
    }
    return deepEqual(espurify(this.signatureAst.callee), espurify(node.callee));
};

Matcher.prototype.isSameDepthAsSignatureCallee = function (ast) {
    var depth = this.signatureCalleeDepth;
    var currentDepth = 0;
    estraverse.traverse(ast, {
        keys: this.visitorKeys,
        enter: function (currentNode, parentNode) {
            var path = this.path();
            var pathDepth = path ? path.length : 0;
            if (currentDepth < pathDepth) {
                currentDepth = pathDepth;
            }
            if (depth < currentDepth) {
                this['break']();
            }
        }
    });
    return (depth === currentDepth);
};

function toArgumentSignature (argSignatureNode) {
    switch(argSignatureNode.type) {
    case syntax.Identifier:
        return {
            name: argSignatureNode.name,
            kind: 'mandatory'
        };
    case syntax.ArrayExpression:
        return {
            name: argSignatureNode.elements[0].name,
            kind: 'optional'
        };
    default:
        return null;
    }
}

function astDepth (ast, visitorKeys) {
    var maxDepth = 0;
    estraverse.traverse(ast, {
        keys: visitorKeys,
        enter: function (currentNode, parentNode) {
            var path = this.path();
            var pathDepth = path ? path.length : 0;
            if (maxDepth < pathDepth) {
                maxDepth = pathDepth;
            }
        }
    });
    return maxDepth;
}

function isCallExpression (node) {
    return node && node.type === syntax.CallExpression;
}

function isCalleeOfParent(currentNode, parentNode) {
    return parentNode && currentNode &&
        parentNode.type === syntax.CallExpression &&
        parentNode.callee === currentNode;
}

function identifiers (node) {
    return node.type === syntax.Identifier;
}

function validateApiExpression (callExpression) {
    if (callExpression.type !== syntax.CallExpression) {
        throw new Error(notCallExprMessage);
    }
    var names = {};
    forEach(callExpression.arguments, function (arg) {
        var name = validateArg(arg);
        if (hasOwn.call(names, name)) {
            throw new Error(duplicatedArgMessage + name);
        } else {
            names[name] = name;
        }
    });
}

function validateArg (arg) {
    var inner;
    switch(arg.type) {
    case syntax.Identifier:
        return arg.name;
    case syntax.ArrayExpression:
        if (arg.elements.length !== 1) {
            throw new Error(invalidFormMessage);
        }
        inner = arg.elements[0];
        if (inner.type !== syntax.Identifier) {
            throw new Error(invalidFormMessage);
        }
        return inner.name;
    default:
        throw new Error(invalidFormMessage);
    }
}

function extractExpressionFrom (tree) {
    var statement, expression;
    statement = tree.body[0];
    if (statement.type !== syntax.ExpressionStatement) {
        throw new Error(notCallExprMessage);
    }
    expression = statement.expression;
    validateApiExpression(expression);
    return expression;
}

module.exports = createMatcher;

},{"array-filter":6,"array-foreach":7,"array-map":8,"array-reduce":13,"deep-equal":14,"esprima":17,"espurify":18,"estraverse":23,"indexof":25}],13:[function(_dereq_,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;

module.exports = function (xs, f, acc) {
    var hasAcc = arguments.length >= 3;
    if (hasAcc && xs.reduce) return xs.reduce(f, acc);
    if (xs.reduce) return xs.reduce(f);
    
    for (var i = 0; i < xs.length; i++) {
        if (!hasOwn.call(xs, i)) continue;
        if (!hasAcc) {
            acc = xs[i];
            hasAcc = true;
            continue;
        }
        acc = f(acc, xs[i], i);
    }
    return acc;
};

},{}],14:[function(_dereq_,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = _dereq_('./lib/keys.js');
var isArguments = _dereq_('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":15,"./lib/keys.js":16}],15:[function(_dereq_,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],16:[function(_dereq_,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],17:[function(_dereq_,module,exports){
/*
  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modific