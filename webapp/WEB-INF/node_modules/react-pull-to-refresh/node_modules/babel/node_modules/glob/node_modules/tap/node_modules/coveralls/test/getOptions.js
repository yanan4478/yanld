var should = require('should');
var index = require('../index');
var getOptions = index.getOptions;
var getBaseOptions = index.getBaseOptions;

describe("getBaseOptions", function(){
  beforeEach(function(){
    process.env = {PATH: process.env.PATH};
  });
  it ("should set service_job_id if it exists", function(done){
    testServiceJobId(getBaseOptions, done);
  });
  it ("should set git hash if it exists", function(done){
    testGitHash(getBaseOptions, done);
  });
  it ("should set git branch if it exists", function(done){
    testGitBranch(getBaseOptions, done);
  });
  it ("should detect current git hash if not passed in", function(done) {
    testGitHashDetection(getBaseOptions, done);
  });
  it ("should detect current git branch if not passed in", function(done) {
    testGitBranchDetection(getBaseOptions, done);
  });
  it ("should detect detached git head if no hash passed in", function(done) {
    testGitDetachedHeadDetection(getBaseOptions, done);
  });
  it ("should fail local Git detection if no .git directory", function(done) {
    testNoLocalGit(getBaseOptions, done);
  });
  it ("should set repo_token if it exists", function(done){
    testRepoToken(getBaseOptions, done);
  });
  it ("should detect repo_token if not passed in", function(done){
    testRepoTokenDetection(getBaseOptions, done);
  });
  it ("should set service_name if it exists", function(done){
    testServiceName(getBaseOptions, done);
  });
  it ("should set service_name and service_job_id if it's running on travis-ci", function(done){
    testTravisCi(getBaseOptions, done);
  });
  it ("should set service_name and service_job_id if it's running on jenkins", function(done){
    testJenkins(getBaseOptions, done);
  });
  it ("should set service_name and service_job_id if it's running on circleci", function(done){
    testCircleCi(getBaseOptions, done);
  });
  it ("should set service_name and service_job_id if it's running on codeship", function(done){
    testCodeship(getBaseOptions, done);
  });
  /*
  it ("should set service_name and service_job_id if it's running on drone", function(done){
    testDrone(getBaseOptions, done);
  });
  */
  it ("should set service_name and service_job_id if it's running on wercker", function(done){
    testWercker(getBaseOptions, done);
  });
});

describe("getOptions", function(){
  beforeEach(function(){
    process.env = {PATH: process.env.PATH};
  });
  it ("should require a callback", function(done) {
    (function() {
      getOptions();
    }).should.throw();
    done();
  });
  it ("should get a filepath if there is one", function(done){
    process.argv[2] = "somepath";
    getOptions(function(err, options){
      options.filepath.should.equal("somepath");
      done();
    });

  });
  it ("should get a filepath if there is one, even in verbose mode", function(done){
    process.argv[2] = "--verbose";
    process.argv[3] = "somepath";
    getOptions(function(err, options){
      options.filepath.should.equal("somepath");
      done();
    });
  });
  it ("should set service_job_id if it exists", function(done){
    testServiceJobId(getOptions, done);
  });
  it ("should set git hash if it exists", function(done){
    testGitHash(getOptions, done);
  });
  it ("should set git branch if it exists", function(done){
    testGitBranch(getOptions, done);
  });
  it ("should detect current git hash if not passed in", function(done) {
    testGitHashDetection(getOptions, done);
  });
  it ("should detect current git branch if not passed in", function(done) {
    testGitBranchDetection(getOptions, done);
  });
  it ("should detect detached git head if no hash passed in", function(done) {
    testGitDetachedHeadDetection(getOptions, done);
  });
  it ("should fail local Git detection if no .git directory", function(done) {
    testNoLocalGit(getOptions, done);
  });
  it ("should set repo_token if it exists", function(done){
    testRepoToken(getOptions, done);
  });
  it ("should detect repo_token if not passed in", function(done){
    testRepoTokenDetection(getOptions, done);
  });
  it ("should set service_name if it exists", function(done){
    testServiceName(getOptions, done);
  });
  it("should set service_pull_request if it exists", function(done){
    testServicePullRequest(getOptions, done);
  });
  it ("should set service_name and service_job_id if it's running on travis-ci", function(done){
    testTravisCi(getOptions, done);
  });
  it ("should set service_name and service_job_id if it's running on jenkins", function(done){
    testJenkins(getOptions, done);
  });
  it ("should set service_name and service_job_id if it's running on circleci", function(done){
    testCircleCi(getOptions, done);
  });
  it ("should set service_name and service_job_id if it's running on codeship", function(done){
    testCodeship(getOptions, done);
  });
  /*
  it ("should set service_name and service_job_id if it's running on drone", function(done){
    testDrone(getBaseOptions, done);
  });
  */
  it ("should set service_name and service_job_id if it's running on wercker", function(done){
    testWercker(getOptions, done);
  });
});

var testServiceJobId = function(sut, done){
    process.env.COVERALLS_SERVICE_JOB_ID = "SERVICE_JOB_ID";
    sut(function(err, options){
      options.service_job_id.should.equal("SERVICE_JOB_ID");
      done();
    });
};

var testGitHash = function(sut, done){
  process.env.COVERALLS_GIT_COMMIT = "e3e3e3e3e3e3e3e3e";
  sut(function(err, options){
    options.git.head.id.should.equal("e3e3e3e3e3e3e3e3e");
    done();
  });
};

var testGitDetachedHeadDetection = function(sut, done){
  var localGit = ensureLocalGitContext({ detached: true });
  sut(function(err, options) {
    options.git.head.id.should.equal(localGit.id);
    localGit.wrapUp();
    done();
  });
};

var testGitHashDetection = function(sut, done){
  var localGit = ensureLocalGitContext();
  sut(function(err, options) {
    options.git.head.id.should.equal(localGit.id);
    localGit.wrapUp();
    done();
  });
};

var testGitBranch = function(sut, done){
  process.env.COVERALLS_GIT_COMMIT = "e3e3e3e3e3e3e3e3e";
  process.env.COVERALLS_GIT_BRANCH = "master";
  sut(function(err, options){
    options.git.branch.should.equal("master");
    done();
  });
};

var testGitBranchDetection = function(sut, done){
  var localGit = ensureLocalGitContext();
  sut(function(err, options) {
    if (localGit.branch)
      options.git.branch.should.equal(localGit.branch);
    else
      options.git.should.not.have.property('branch');
    localGit.wrapUp();
    done();
  });
};

var testNoLocalGit = function(sut, done){
  var localGit = ensureLocalGitContext({ noGit: true });
  sut(function(err, options) {
    options.should.not.have.property('git');
    localGit.wrapUp();
    done();
  });
};

var testRepoToken = function(sut, done){
  process.env.COVERALLS_REPO_TOKEN = "REPO_TOKEN";
  sut(function(err, options){
    options.repo_token.should.equal("REPO_TOKEN");
    done();
  });
};

var testRepoTokenDetection = function(sut, done) {
  var fs = require('fs');
  var path = require('path');

  var file = path.join(process.cwd(), '.coveralls.yml'), token, service_name, synthetic = false;
  if (fs.exists(file)) {
    var yaml = require('js-yaml');
    var coveralls_yml_doc = yaml.safeLoad(fs.readFileSync(yml, 'utf8'));
    token = coveralls_yml_doc.repo_token;
    if(coveralls_yml_doc.service_name) {
      service_name = coveralls_yml_doc.service_name;
    }
  } else {
    token = 'REPO_TOKEN';
    service_name = 'travis-pro';
    fs.writeFileSync(file, 'repo_token: ' + token+'\nservice_name: ' + service_name);
    synthetic = true;
  }
  sut(fu