#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander')
  , sprintf = require('util').format
  , path = require('path')
  , fs = require('fs')
  , glob = require('glob')
  , resolve = path.resolve
  , exists = fs.existsSync || path.existsSync
  , Mocha = require('../')
  , utils = Mocha.utils
  , interfaces = Mocha.interfaces
  , join = path.join
  , basename = path.basename
  , cwd = process.cwd()
  , mocha = new Mocha;

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = global.Date
  , setTimeout = global.setTimeout
  , setInterval = global.setInterval
  , clearTimeout = global.clearTimeout
  , clearInterval = global.clearInterval;

/**
 * Files.
 */

var files = [];

/**
 * Globals.
 */

var globals = [];

/**
 * Requires.
 */

var requires = [];

/**
 * Images.
 */

var images = {
    fail: __dirname + '/../images/error.png'
  , pass: __dirname + '/../images/ok.png'
};

// options

program
  .version(JSON.parse(fs.readFileSync(__dirname + '/../package.json', 'utf8')).version)
  .usage('[debug] [options] [files]')
  .option('-A, --async-only', "force all tests to take a callback (async)")
  .option('-c, --colors', 'force enabling of colors')
  .option('-C, --no-colors', 'force disabling of colors')
  .option('-G, --growl', 'enable growl notification support')
  .option('-R, --reporter <name>', 'specify the reporter to use', 'spec')
  .option('-S, --sort', "sort test files")
  .option('-b, --bail', "bail after first test failure")
  .option('-d, --debug', "enable node's debugger, synonym for node --debug")
  .option('-g, --grep <pattern>', 'only run tests matching <pattern>')
  .option('-gc', '--expose-gc', 'expose gc extension')
  .option('-i, --invert', 'inverts --grep matches')
  .option('-r, --require <name>', 'require the given module')
  .option('-s, --slow <ms>', '"slow" test threshold in milliseconds [75]')
  .option('-t, --timeout <ms>', 'set test-case timeout in milliseconds [2000]')
  .option('-u, --ui <name>', 'specify user-interface (bdd|tdd|exports)', 'bdd')
  .option('-w, --watch', 'watch files for changes')
  .option('--check-leaks', 'check for global variable leaks')
  .option('--compilers <ext>:<module>,...', 'use the given module(s) to compile files', list, [])
  .option('--debug-brk', "enable node's debugger breaking on the first line")
  .option('--globals <names>', 'allow the given comma-delimited global [names]', list, [])
  .option('--harmony', 'enable all harmony features (except typeof)')
  .option('--harmony-collections', 'enable harmony collections (sets, maps, and weak maps)')
  .option('--harmony-generators', 'enable harmony generators')
  .option('--harmony-proxies', 'enable harmony proxies')
  .option('--inline-diffs', 'display actual/expected differences inline within each string')
  .option('--interfaces', 'display available interfaces')
  .option('--no-deprecation', 'silence deprecation warnings')
  .option('--no-exit', 'require a clean shutdown of the event loop: mocha will not call process.exit')
  .option('--no-timeouts', 'disables timeouts, given implicitly with --debug')
  .option('--opts <path>', 'specify opts path', 'test/mocha.opts')
  .option('--prof', 'log statistical profiling information')
  .option('--recursive', 'include sub directories')
  .option('--reporters', 'display available reporters')
  .option('--throw-deprecation', 'throw an exception anytime a deprecated function is used')
  .option('--trace', 'trace function calls')
  .option('--trace-deprecation', 'show stack traces on deprecations')
  .option('--watch-extensions <ext>,...', 'additional extensions to monitor with --watch', list, [])

program.name = 'mocha';

// init command

program
  .command('init <path>')
  .description('initialize a client-side mocha setup at <path>')
  .action(function(path){
    var mkdir = require('mkdirp');
    mkdir.sync(path);
    var css = fs.readFileSync(join(__dirname, '..', 'mocha.css'));
    var js = fs.readFileSync(join(__dirname, '..', 'mocha.js'));
    var tmpl = fs.readFileSync(join(__dirname, '..', 'lib/template.html'));
    fs.writeFileSync(join(path, 'mocha.css'), css);
    fs.writeFileSync(join(path, 'mocha.js'), js);
    fs.writeFileSync(join(path, 'tests.js'), '');
    fs.writeFileSync(join(path, 'index.html'), tmpl);
    process.exit(0);
  });

// --globals

program.on('globals', function(val){
  globals = globals.concat(list(val));
});

// --reporters

program.on('reporters', function(){
  console.log();
  console.log('    dot - dot matrix');
  console.log('    doc - html documentation');
  console.log('    spec - hierarchical spec list');
  console.log('    json - single json object');
  console.log('    progress - progress bar');
  console.log('    list - spec-style listing');
  console.log('    tap - test-anything-protocol');
  console.log('    landing - unicode landing strip');
  console.log('    xunit - xunit reporter');
  console.log('    html-cov - HTML test coverage');
  console.log('    json-cov - JSON test coverage');
  console.log('    min - minimal reporter (great with --watch)');
  console.log('    json-stream - newline delimited json events');
  console.log('    markdown - markdown documentation (github flavour)');
  console.log('    nyan - nyan cat!');
  console.log();
  process.exit();
});

// --interfaces

program.on('interfaces', function(){
  console.log('');
  console.log('    bdd');
  console.log('    tdd');
  console.log('    qunit');
  console.log('    exports');
  console.log('');
  process.exit();
});

// -r, --require

module.paths.push(cwd, join(cwd, 'node_modules'));

program.on('require', function(mod){
  var abs = exists(mod) || exists(mod + '.js');
  if (abs) mod = resolve(mod);
  requires.push(mod);
});

// --opts

var optsPath = process.argv.indexOf('--opts') !== -1
    ? process.argv[process.argv.indexOf('--opts') + 1]
    : 'test/mocha.opts';

try {
  var opts = fs.readFileSync(optsPath, 'utf8')
    .trim()
    .split(/\s+/);

  process.argv = process.argv
    .slice(0, 2)
    .concat(opts.concat(process.argv.slice(2)));
} catch (err) {
  // ignore
}

// parse args

prog